app:
  security:
    encryption:
      # Generate a strong, random Base64 encoded key (16, 24, or 32 bytes decoded)
      # Example for AES-256 (32 bytes = 256 bits):
      # Generate with: openssl rand -base64 32
      passkey-data-key: ${APP_PASSKEY_ENCRYPTION_KEY} # Load from .env, which is seeded to Vault
  ssl:
    trust-store:
      # Use 'file:' for filesystem or 'classpath:' if packaged in JAR
      path: classpath:config/central-truststore.jks
      #      path: file:./config/central-truststore.jks
      # LOAD SECURELY! Use environment variable for the password.
      # Password for the truststore, to be loaded from Vault if sensitive
      # For now, assuming AUTHSERVER_APP_CENTRAL_TRUSTSTORE_PASSWORD is an env var Spring Boot picks up
      # or you can map it from Vault: ${authserver.security.truststore.password}
      password: ${AUTHSERVER_APP_CENTRAL_TRUSTSTORE_PASSWORD}

# JTE - server-side rendering
gg:
  jte:
    developmentMode: true

# Spring Actuator - metrics
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics # Expose prometheus and metrics
  metrics:
    tags:
      application: ${spring.application.name}


oauth2:
  clients:
    shopClient:
      secret: ${oauth2.clients.shopClient.secret} # This is the key Spring Boot resolves     # type: JKS # Optional: Specify type if not JKS

spring:
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration

  application:
    name: ${AS_NAME:authserver}
  #  config:
  #    import: application_prod.yml
  #  profiles:
  #    active: default

  # --- Spring Cloud Vault Configuration ---
  cloud:
    vault:
      enabled: true
      fail-fast: true # Set to false for local dev if Vault isn't always up when starting authserver
      uri: http://localhost:8200 # Your local Vault address
      connection-timeout: 5000
      read-timeout: 15000
      # --- Authentication: TOKEN for local dev, AppRole for prod ---
      authentication: TOKEN
      token: ${VAULT_TOKEN}   # Read from environment variable VAULT_TOKEN (set this in your .env)

      kv:
        enabled: true
        backend: secret    # Default KV v2 mount path
        # Spring Cloud Vault will automatically try paths like:
        # secret/data/authserver/        (for common app secrets)
        # secret/data/authserver,local/  (for profile-specific secrets if spring.profiles.active=local)
        # secret/data/application/       (for global application secrets)
        # We will put secrets in secret/data/authserver/local/ for this example.
        # default-context: "authserver" # This would make it look in secret/data/authserver/
        # profile-separator: "/" # Default is comma, but slash is common for path-like profiles

  # --- Import Vault Secrets ---
  # This tells Spring to load configuration from Vault.
  # Properties from Vault will override those in this file if names match.
  config:
    import:
      #      - "optional:vault://" # General import, Spring Cloud Vault uses default paths
      # You can be more specific if needed:
      - "optional:vault://secret/authserver/local"

  data:
    redis:
      # For local development, authserver runs on host, Valkey in Docker
      host: ${VALKEY_HOST_LOCAL:localhost}
      port: ${VALKEY_PORT_LOCAL:6379} # The port mapped in docker-compose.override.yml
      password: ${VALKEY_PASSWORD}    # Ensure this is in authserver's .env or Vault
      ssl:
        enabled: true # Assuming your Valkey is configured for TLS as per docker-compose healthcheck
        #        bundle: central-truststore-for-redis # Reference the SSL bundle defined in ssl
        bundle: redis-client-mtls-bundle # for tls-auth-clients yes in valkey.conf
      # Configure Redis connection pool
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 2
          max-wait: -1ms
      # Configure Redis client options
      client-type: lettuce
      connect-timeout: 5000ms
      timeout: 10000ms

  datasource:
    # Credentials will be overridden by Vault if keys like 'spring.datasource.username' and
    # 'spring.datasource.password' exist in secret/data/authserver/local (or secret/data/authserver)
    # If the file path changed, adapt accordingly
    #    url: jdbc:mysql://localhost:3406/amlume_db?sslMode=VERIFY_CA&trustCertificateKeyStoreUrl=file:./config/central-truststore.jks&trustCertificateKeyStoreType=JKS&trustCertificateKeyStorePassword=${APP_CENTRAL_TRUSTSTORE_PASSWORD} # <-- Corrected and password added
    #    url: jdbc:mysql://localhost:3406/amlume_db?sslMode=VERIFY_CA&trustCertificateKeyStoreUrl=file:./config/central-truststore.jks&trustCertificateKeyStoreType=JKS
    #    url: jdbc:mysql://localhost:3406/amlume_db?sslMode=DISABLED
    url: jdbc:mysql://${AUTH_DB_HOST:localhost}:${AUTH_DB_PORT_LOCAL:3407}/${AUTH_DB_NAME:amlume_auth_db}?sslMode=DISABLED&allowPublicKeyRetrieval=true
    #    url: jdbc:mysql://${AUTH_DB_HOST:localhost}:${AUTH_DB_PORT_LOCAL:3306}/${AUTH_DB_NAME:amlume_auth_db}
    username: ${spring.datasource.username}
    password: ${spring.datasource.password}
    driverClassName: com.mysql.cj.jdbc.Driver

  docker:
    compose:
      enabled: false # Disable Spring Boot's automatic Docker Compose management for local profile

  initial-root-user:
    email: ${ROOT_USER_EMAIL}
    password: ${ROOT_USER_PASSWORD}

  jackson:
    default-property-inclusion: non_null
    deserialization:
      fail-on-unknown-properties: false
      accept-empty-string-as-null-object: true
    serialization:
      write-dates-as-timestamps: false
      fail-on-empty-beans: false
    mapper:
      accept-case-insensitive-properties: true
    property-naming-strategy: SNAKE_CASE
    time-zone: UTC
  # --- JPA / Hibernate ---
  # Disable open-in-view for performance
  jpa:
    database-platform: org.hibernate.dialect.MySQLDialect
    show-sql: true
    hibernate:
      ddl-auto: update # Use "update" for dev, create-drop if schema changes, "validate" or "none" for prod
      show-sql: true
    properties:
      hibernate:
        format_sql: true
        jdbc:
          lob:
            non_contextual_creation: true
          time_zone: UTC

  mail:
    host=smtp-relay.brevo.com
    port=587
    username=your_brevo_email@example.com
    password=your_brevo_smtp_password
    properties.mail.smtp.auth=true
    properties.mail.smtp.starttls.enable=true

  main:
    web-application-type: servlet # or reactive

  #  mvc:
  #    pathmatch:
  #      matching-strategy: ant_path_matcher

  security:
    oauth2:
      #      authorizationserver:
      #        client:
      #          public-client:
      #            registration:
      #              client-id: "public-client"
      #              client-authentication-methods:
      #                - "none"
      #              authorization-grant-types:
      #                - "authorization_code"
      #              redirect-uris:
      #                - "http://127.0.0.1:8080"
      #              scopes:
      #                - "openid"
      #                - "profile"
      #            require-authorization-consent: true
      #            # require-proof-key setting is important to prevent PKCE downgrade attacks
      #            require-proof-key: true

      client:
        registration:
          google:
            # client-id and client-secret will be overridden by Vault if keys like
            # 'spring.security.oauth2.client.registration.google.client-id' and
            # 'spring.security.oauth2.client.registration.google.client-secret'
            # exist in secret/data/authserver/local (or secret/data/authserver)
            client-id: ${spring.security.oauth2.client.registration.google.client-id} # Matches key in Vault
            client-secret: ${spring.security.oauth2.client.registration.google.client-secret} # Matches key in Vault
            scope: openid, profile, email
            #            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}" # Default pattern
            redirect-uri: "https://localhost:9000/login/oauth2/code/{registrationId}" # Default pattern
          github:
            client-id: ${spring.security.oauth2.client.registration.github.client-id} # Matches key in Vault
            client-secret: ${spring.security.oauth2.client.registration.github.client-secret} # Matches key in Vault
            scope: read:user, user:email # Ensure 'user:email' for primary email
            #            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}" # Default pattern
            redirect-uri: "https://localhost:9000/login/oauth2/code/{registrationId}" # Default pattern
        # provider: # Often auto-discovered for OIDC, or common providers are pre-configured
        #   google:
        #     issuer-uri: https://accounts.google.com
    rememberme:
      key: ${spring.security.rememberme.key} # Matches key in Vault
    webauthn:
      rpName: "Amlume Passkeys"
      # Replace it with the domain name of the application
      rpId: localhost
      allowedOrigins:
        - "http://localhost:8080" # amlume-shop
        #        - "http://localhost:9000" # authserver itself if its UI uses WebAuthn
        - "https://localhost:9000" # authserver itself if its UI uses WebAuthn
        # Replace with the URL of the application. Notice: this _MUST_ be an HTTPS URL with a valid certificate

#    client:
#      registration:
#        amlumeclient:
#          client-id: amlumeclient
#          client-secret: Qw3rTy6UjMnB9zXcV2pL0sKjHn5TxQqB
#          authorization-grant-type: authorization_code
#          redirect-uri: "{baseUrl}/login/oauth2/code/amlumeclient"
#          scope: openid,profile,email
#      provider:
#        amlumeauth:
#          issuer-uri: http://localhost:9000

  # --- Spring Session Configuration ---
  session:
    #    store-type: redis
    timeout: 30m # Example: 30 minutes session timeout
    redis:
      # Namespace to keep authserver sessions separate if sharing Redis instance
      namespace: "authserver:session:amlume"
      #      namespace: "amlume:authserver:session"
      #      repository-type: default # default or indexed, uses RedisIndexedSessionRepository. Or use annotation-based SessionRepository
      # flush-mode: ON_SAVE # Default, saves on every change
      # save-mode: ON_SET_ATTRIBUTE # Default is ON_SET_ATTRIBUTE. ALWAYS ensures session attributes are persisted. ON_GET_ATTRIBUTE is less performant, as it saves on every request.
      # time-to-live: 30m # Default
      configure-action: none # Disable auto-configuration to use our custom config
    # Configure session cookie
    secure-cookie: true # Set to false for local HTTP development if needed
    cookie:
      name: AMLUAUTHJSESSIONID
      http-only: true
      secure: true
      same-site: lax
      max-age: 7200s # 2 hours

  ssl: # This is where bundles are defined
    bundle:
      jks: # pkcs12 Or jks if your central-truststore is directly usable as a JKS bundle for Redis
        redis-client-mtls-bundle:
          key.alias: authservervalkeyclient                                  # Alias used when creating the client keystore
          keystore:
            location: classpath:config/authserver-valkey-client-keystore.p12 # Path to your NEW client keystore
            #            password: your_central_truststore_password
            password: ${AUTHSERVER_VALKEY_CLIENT_KEYSTORE_PASSWORD}         # Password for this new client keystore
            type: PKCS12 # PKCS12 Or JKS, etc.
          truststore: # This is to trust Valkey's SERVER certificate
            location: classpath:config/authserver-valkey-truststore.p12
            #          location: ${app.ssl.trust-store.path} # e.g., classpath:config/central-truststore.jks
            #            password: your_central_truststore_password
            password: ${AUTHSERVER_VALKEY_TRUSTSTORE_PASSWORD}
            type: PKCS12 # PKCS12 if your truststore is .p12. or JKS

  #         authserver-https-bundle:
  #           keystore:
  #             location: classpath:config/authserver-server-keystore.p12
  #             password: your_central_truststore_password # Or placeholder
  #             alias: authserverhttps
  #             type: PKCS12

  # --- Virtual Threads ---
  threads:
    virtual:
      enabled: true

server:
  port: ${AS_SERVER_PORT:9000}
  #  connection-timeout: 30s
  #  context-path: /authserver
  error:
    whitelabel:
      enabled: true # For production, disable Spring Boot's default error page
    path: /user-error
    include-exception: true
  #    include-stacktrace: always
  #    include-message: always
  ssl:
    enabled: true
    #     bundle: authserver-https-bundle # This bundle would also be defined under spring.ssl.bundle.jks
    key-store: classpath:config/authserver-server-keystore.p12 # Path to your keystore
    #    key-store-password: your_central_truststore_password
    key-store-password: ${AUTHSERVER_SERVER_KEYSTORE_PASSWORD} # modify the vault-seeder accordingly
    key-alias: authserverhttps # Alias used during P12 creation
    key-store-type: PKCS12 # Or JKS, etc.
    protocols: TLSv1.2,TLSv1.3 #Or just TLS

  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css,image/svg+xml
    min-response-size: 1024 # Compress responses larger than 1KB
    # For Brotli (if your server setup supports it and you prefer it over Gzip)
    brotli:
      enabled: true

  max-http-request-header-size: 16KB # Default is 8KB, which is too small for some headers
  tomcat:
    max-swallow-size: 2MB # The maximum size of a request body. Default is 1MB
    max-http-form-post-size: 2MB # The maximum size of the whole post-request.
    accesslog:
      enabled: true
      pattern: "%h %l %t %r %s %b %D %S"
      #      directory: /logs # User must have write access
      directory: ./target/tomcat-access-logs # or an absolute path user have write access
      file-date-format: yyyy-MM-dd
      prefix: access_log
      suffix: .log

  servlet:
    session:
      cookie:
        name: AMLUAUTHJSESSIONID # Custom session cookie name for authserver
        http-only: true
        secure: true # True because you are using HTTPS
        same-site: Lax # Good default for security and usability
        # max-age: 1800s # Optional: aligns with spring.session.timeout if needed

logging:
  level:
    io.netty: DEBUG # Or TRACE for even more detail
    javax.net.ssl: DEBUG # For JVM-level SSL debugging
    org:
      springframework:
        boot.autoconfigure.ssl: DEBUG # or TRACE
        boot.ssl: DEBUG # or TRACE
        #        security: ${SPRING_SECURITY_LOG_LEVEL:TRACE}
        security: TRACE
        security.web.util.matcher: TRACE
        security.web.webauthn: TRACE
        security.web.webauthn.client: TRACE
        security.web.webauthn.client.registration: TRACE
        security.web.webauthn.client.registration.oauth2: TRACE
        session: DEBUG # Add this to see Spring Session details
        data.redis: DEBUG # Add this to see Redis operations

        web: DEBUG
        cache: TRACE # Set to TRACE to see cache hits/misses logged by Spring
        #        security: ${SPRING_SECURITY_LOG_LEVEL:INFO} # Reduce default to INFO
        cloud.vault: DEBUG # Keep vault logging at DEBUG for setup
        vault.core: DEBUG
    #    root: DEBUG
    com.webauthn4j: TRACE
    io.lettuce.core.protocol.ConnectionWatchdog: TRACE
    me.amlu.authserver: DEBUG
    me.amlu.authserver.config.LocalSecurityConfig: TRACE
    me.amlu.authserver.security.WebAuthnPrincipalSettingSuccessHandler: DEBUG
  #    me.amlu.shop.amlume_shop: DEBUG
  #    me.amlu.shop.amlume_shop.config: DEBUG # Ensure config loading is visible
  #    me.amlu.shop.amlume_shop.service: DEBUG
  #    me.amlu.shop.amlume_shop.controller: DEBUG
  #    me.amlu.shop.amlume_shop.repository: DEBUG
  #    me.amlu.shop.amlume_shop.util: DEBUG
  #    me.amlu.shop.amlume_shop.exception: DEBUG
  #    me.amlu.shop.amlume_shop.model: DEBUG
  #    me.amlu.shop.amlume_shop.security: DEBUG
  #    me.amlu.shop.amlume_shop.security.oauth2: DEBUG
  pattern:
    console: ${LOGPATTERN_CONSOLE:%green(%d{HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%logger{15}) - %msg%n}

    # --- Define properties for OAuth2 client secrets to be loaded from Vault for seeding ---
    # These will be injected into LocalSecurityConfig using @Value
    # Spring Cloud Vault will populate these if keys like 'oauth2.clients.amlumeapi.secret'
    # are found in secret/data/authserver/local (or secret/data/authserver)
    oauth2:
      clients:
        amlumeapi:
          secret: ${oauth2.clients.amlumeapi.secret} # Matches key in Vault
        amlumeintrospect:
          secret: ${oauth2.clients.amlumeintrospect.secret} # Matches key in Vault
        shopClient:
          secret: ${oauth2.clients.shopClient.secret} # Matches key in Vault
        postmanClient:
          secret: ${oauth2.clients.postmanClient.secret} # Matches key in Vault
